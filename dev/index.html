<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · MultiDimEquations.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MultiDimEquations.jl Documentation</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Index</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#The-MultiDimEquations-Module"><span>The MultiDimEquations Module</span></a></li><li><a class="tocitem" href="#Module-Index"><span>Module Index</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Detailed-API"><span>Detailed API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MultiDimEquations.jl"><a class="docs-heading-anchor" href="#MultiDimEquations.jl">MultiDimEquations.jl</a><a id="MultiDimEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MultiDimEquations.jl" title="Permalink"></a></h1><p>Documentation for the <a href="https://github.com/sylvaticus/MultiDimEquations.jl">MultiDimEquations.jl</a> package</p><h1 id="The-MultiDimEquations-Module"><a class="docs-heading-anchor" href="#The-MultiDimEquations-Module">The MultiDimEquations Module</a><a id="The-MultiDimEquations-Module-1"></a><a class="docs-heading-anchor-permalink" href="#The-MultiDimEquations-Module" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="MultiDimEquations" href="#MultiDimEquations"><code>MultiDimEquations</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">MultiDimEquations</code></pre><p>The package provides handy functions to work with NDSparse (from IndexedTables.jl package) or standard arrays in order to write equations in a concise and readable way. The formers can be accessed by name, but are somehow slower, the latters are faster but need to be accessed by position.</p><p><code>defVars()</code> defines either empty NDSparse with the dimensions (axis) required or arrays with the required size and prefilled with <code>missing</code> values. More variables can be defined at once.</p><p><code>defLoadVar()</code> and <code>defLoadVars()</code> allow to define and import the variables from a DataFrame in long format (dim1|dim2|...|value), with the second one allowing to import more varaibles at once, given the presence of a column in the database with the variable names.</p><p><code>@meq</code> is a macro that allows to write your &quot;model equations&quot; more concisely, e.g. <code>@meq par1[d1 in DIM1, d2 in DIM2, dfix3] =  par2[d1,d2]+par3[d1,d2]</code> would be expanded to use the list comprehension expression above: <code>[par1[d1,d2,dfix3] =  par2[d1,d2]+par3[d1,d2] for d1 in DIM1, d2 in DIM2]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/67b80d04cb0e1a1776bdaefff3a10339668dafe7/src/MultiDimEquations.jl#L1-L23">source</a></section></article><h2 id="Module-Index"><a class="docs-heading-anchor" href="#Module-Index">Module Index</a><a id="Module-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Index" title="Permalink"></a></h2><ul><li><a href="index.html#MultiDimEquations.defLoadVar-Tuple{Any, Any}"><code>MultiDimEquations.defLoadVar</code></a></li><li><a href="index.html#MultiDimEquations.defLoadVars-Tuple{Any, Any, Any}"><code>MultiDimEquations.defLoadVars</code></a></li><li><a href="index.html#MultiDimEquations.defVars-Tuple{Any}"><code>MultiDimEquations.defVars</code></a></li><li><a href="index.html#MultiDimEquations.defVars-Tuple{Any, Any}"><code>MultiDimEquations.defVars</code></a></li><li><a href="index.html#MultiDimEquations.getSafe"><code>MultiDimEquations.getSafe</code></a></li><li><a href="index.html#MultiDimEquations.toDataFrame-Tuple{IndexedTables.NDSparse}"><code>MultiDimEquations.toDataFrame</code></a></li><li><a href="index.html#MultiDimEquations.@meq-Tuple{Any}"><code>MultiDimEquations.@meq</code></a></li></ul><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><h3 id="Input-data..."><a class="docs-heading-anchor" href="#Input-data...">Input data...</a><a id="Input-data...-1"></a><a class="docs-heading-anchor-permalink" href="#Input-data..." title="Permalink"></a></h3><pre><code class="language-julia">df = CSV.read(IOBuffer(&quot;&quot;&quot;
reg prod var value
us banana production 10
us banana transfCoef    0.6
us banana trValues      2
us apples production    7
us apples transfCoef    0.7
us apples trValues      5
us juice production     missing
us juice transfCoef     missing
us juice trValues       missing
eu banana production    5
eu banana transfCoef    0.7
eu banana trValues      1
eu apples production    8
eu apples transfCoef    0.8
eu apples trValues 4
eu juice production missing
eu juice transfCoef missing
eu juice trValues missing
&quot;&quot;&quot;), DataFrame, delim=&quot; &quot;, ignorerepeated=true, copycols=true, missingstring=&quot;missing&quot;)</code></pre><h3 id="...using-NDSparse:"><a class="docs-heading-anchor" href="#...using-NDSparse:">...using NDSparse:</a><a id="...using-NDSparse:-1"></a><a class="docs-heading-anchor-permalink" href="#...using-NDSparse:" title="Permalink"></a></h3><pre><code class="language-julia">reg      = unique(df.reg)
products = unique(df.prod)
primPr   = products[1:2]
secPr    = [products[3]]

(production,transfCoef,trValues) = defLoadVars([&quot;production&quot;,&quot;transfCoef&quot;,&quot;trValues&quot;], df,[&quot;reg&quot;,&quot;prod&quot;], varNameCol=&quot;var&quot;, valueCol=&quot;value&quot;,sparse=true)
consumption                      = defVars([&quot;reg&quot;,&quot;prod&quot;],[String,String])

# equivalent to [production[r, sp] = sum(trValues[r,pp] * transfCoef[r,pp]  for pp in primPr) for r in reg, sp in secPr]
@meq production[r in reg, sp in secPr]   = sum(trValues[r,pp] * transfCoef[r,pp]  for pp in primPr)
@meq consumption[r in reg, pp in primPr] = production[r,pp] - trValues[r,pp]
@meq consumption[r in reg, sp in secPr]  = production[r, sp]</code></pre><h3 id="...using-normal-arrays:"><a class="docs-heading-anchor" href="#...using-normal-arrays:">...using normal arrays:</a><a id="...using-normal-arrays:-1"></a><a class="docs-heading-anchor-permalink" href="#...using-normal-arrays:" title="Permalink"></a></h3><pre><code class="language-julia">reg      = unique(df.reg)
products = unique(df.prod)
primPrIdx = [1,2]
secPrIdx  = [3]

(production,transfCoef,trValues) = defLoadVars([&quot;production&quot;,&quot;transfCoef&quot;,&quot;trValues&quot;], df,[&quot;reg&quot;,&quot;prod&quot;], varNameCol=&quot;var&quot;, valueCol=&quot;value&quot;,sparse=false)
consumption                      = defVars([length(reg),length(products))

@meq production[r in eachindex(reg), sp in secPrIdx]   =  sum(trValues[r,pp] * transfCoef[r,pp]  for pp in primPrIdx)
@meq consumption[r in eachindex(reg), pp in primPrIdx] = production[r,pp] - trValues[r,pp]
@meq consumption[r in eachindex(reg), sp in secPrIdx]  = production[r, sp]</code></pre><h2 id="Detailed-API"><a class="docs-heading-anchor" href="#Detailed-API">Detailed API</a><a id="Detailed-API-1"></a><a class="docs-heading-anchor-permalink" href="#Detailed-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MultiDimEquations.defLoadVar-Tuple{Any, Any}" href="#MultiDimEquations.defLoadVar-Tuple{Any, Any}"><code>MultiDimEquations.defLoadVar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">defLoadVar(df, dimsNameCols; &lt;keyword arguments&gt;)</code></pre><p>Define the required IndexedTables or Arrays and load the data from a DataFrame in long format while specifing the dimensional columns.</p><p><strong>Arguments</strong></p><ul><li><code>df</code>: The source of the dataframe, that must be in the format dim1|dim2|...|value</li><li><code>dimsNameCols</code>: The names of the columns corresponding to the dimensions over which the variables are defined (the keys)</li><li><code>valueCol (def: &quot;value&quot;)</code>: The name of the column in the df containing the values</li><li><code>sparse (def: &quot;true&quot;)</code>: Wheter to return <code>NDSparse</code> elements (from IndexedTable) or standard arrays</li><li><code>missingValue</code> (def=<code>missing</code>): How to fill the matrix with (relevant only for arrays)</li></ul><p><strong>Notes</strong></p><ul><li>Sparse indexed tables can be accessed by element but are slower, standard arrays need to be accessed by position but are faster</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; vol  = defVars(volumeData,[&quot;region&quot;,&quot;treeSpecie&quot;,&quot;year&quot;], valueCol=&quot;value&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/67b80d04cb0e1a1776bdaefff3a10339668dafe7/src/MultiDimEquations.jl#L102-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiDimEquations.defLoadVars-Tuple{Any, Any, Any}" href="#MultiDimEquations.defLoadVars-Tuple{Any, Any, Any}"><code>MultiDimEquations.defLoadVars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">defLoadVars(vars, df, dimsNameCols; &lt;keyword arguments&gt;)</code></pre><p>Define the required IndexedTables or Arrays and load the data from a DataFrame in long format while specifing the dimensional columns and the column containing the variable names.</p><p>Like <code>varLoadVar</code> but here we are extracting multiple variables at once, with one column of the input dataframe storing the variable name.</p><p><strong>Arguments</strong></p><ul><li><code>vars</code>: The array of variables to lookup</li><li><code>df</code>: The source of the dataframe, that must be in the format dim1|dim2|...|varName|value</li><li><code>dimsNameCols</code>: The name of the column containing the dimensions over which the variables are defined</li><li><code>varNameCol (def: &quot;varName&quot;)</code>: The name of the column in the df containing the variables names</li><li><code>valueCol (def: &quot;value&quot;)</code>: The name of the column in the df containing the values</li><li><code>sparse (def: &quot;true&quot;)</code>: Wheter to return <code>NDSparse</code> elements (from IndexedTable) or standard arrays</li><li><code>missingValue</code> (def=<code>missing</code>): How to fill the matrix with (relevant only for arrays)</li><li><code>fullKeys</code> (def=<code>true</code>): Wheter all the outputed variables should be based on the full set of keys,  or look for each of them on the keys found specifically for it in the filtered input dataframe</li></ul><p><strong>Notes</strong></p><ul><li>Sparse indexed tables can be accessed by element but are slower, standard arrays need to be accessed by position but are faster</li><li>At the moment <code>sameKeys=true</code> is implemented only for the non-sparse case</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; (vol,numberOfTrees)  = defVars([&quot;vol&quot;,&quot;numberOfTrees&quot;], forestData,[&quot;region&quot;,&quot;treeSpecie&quot;,&quot;year&quot;], varNameCol=&quot;parName&quot;, valueCol=&quot;value&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/67b80d04cb0e1a1776bdaefff3a10339668dafe7/src/MultiDimEquations.jl#L172-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiDimEquations.defVars-Tuple{Any, Any}" href="#MultiDimEquations.defVars-Tuple{Any, Any}"><code>MultiDimEquations.defVars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">defVars(dimNames, dimTypes; &lt;keyword arguments&gt;)</code></pre><p>Define empty NDSparse IndexedTable(s) with the specific dimension(s) and type.</p><p><strong>Arguments</strong></p><ul><li><code>dimNames</code>: Array of names of the dimensions to define</li><li><code>dimTypes</code>: Array of types of the dimensions</li><li><code>valueType</code> (def: <code>Float64</code>):  Type of the value column of the table</li><li><code>n</code> (def=<code>1</code>): Number of copies of the specified tables to return (useful to define multiple variables at once. In such cases a tuple is returned)</li></ul><p><strong># Examples</strong></p><p><strong>```julia</strong></p><p><strong>julia&gt; price,demand,supply = defVars([&quot;region&quot;,&quot;item&quot;,&quot;class&quot;],[String,String,Int64],valueType=Float64,n=3 )</strong></p><p><strong>julia&gt; waterContent = defVars([&quot;region&quot;,&quot;item&quot;],[String,String])</strong></p><p><strong>julia&gt; price[&quot;US&quot;,&quot;apple&quot;,1] = 3.2</strong></p><p><strong>julia&gt; waterContent[&quot;US&quot;,&quot;apple&quot;] = 0.2</strong></p><p><strong>```</strong></p><p><strong></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/67b80d04cb0e1a1776bdaefff3a10339668dafe7/src/MultiDimEquations.jl#L36-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiDimEquations.defVars-Tuple{Any}" href="#MultiDimEquations.defVars-Tuple{Any}"><code>MultiDimEquations.defVars</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">defVars(size; &lt;keyword arguments&gt;)</code></pre><p>Define multidimensional array(s) with the specific dimension(s) and type filled all with <code>missing</code> values.</p><p><strong>Arguments</strong></p><ul><li><code>size</code>: Tuple of the dimensions required</li><li><code>valueType</code> (def: <code>Float64</code>):  Inner type of the array required</li><li><code>n</code> (def=<code>1</code>): Number of copies of the specified tables to return (useful to define multiple variables at once. In such cases a tuple is returned)</li><li><code>missingValue</code> (def=<code>missing</code>): How to fill the matrix with</li></ul><p><strong># Examples</strong></p><p><strong>```julia</strong></p><p><strong>julia&gt; price,demand,supply = defVars((3,4,5),valueType=Float64,n=3 )</strong></p><p><strong>julia&gt; waterContent = defVars((3,4))</strong></p><p><strong>julia&gt; price[2,3,1] = 3.2</strong></p><p><strong>julia&gt; waterContent[2,3] = 0.2</strong></p><p><strong>```</strong></p><p><strong></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/67b80d04cb0e1a1776bdaefff3a10339668dafe7/src/MultiDimEquations.jl#L64-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiDimEquations.getSafe" href="#MultiDimEquations.getSafe"><code>MultiDimEquations.getSafe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getSafe(idxtable,indices,missingValue=missing)</code></pre><p>Return the value stored in a NDSParse table or missingValue if the specified keys are not present.</p><p><strong>Arguments</strong></p><ul><li><code>idxtable</code>: The NDSParse table to lookup</li><li><code>indices</code>: A tuple with the indices to use (<code>:</code> is supported)</li><li><code>missingValue</code>: The value to return if the specified keys are not found</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; volBlackForest2014  = getSafe(forestVolumes,(&quot;BlackForest&quot;,2014),0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/67b80d04cb0e1a1776bdaefff3a10339668dafe7/src/MultiDimEquations.jl#L338-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiDimEquations.toDataFrame-Tuple{IndexedTables.NDSparse}" href="#MultiDimEquations.toDataFrame-Tuple{IndexedTables.NDSparse}"><code>MultiDimEquations.toDataFrame</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">toDataFrame(idxtable::NDSparse)</code></pre><p>Convert a single-value-column NDSParse table to <code>DataFrame</code>.</p><p><strong>Arguments</strong></p><ul><li><code>idxtable</code>: The NDSParse table to convert</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; content = [[&quot;banana&quot;,&quot;banana&quot;,&quot;apple&quot;,&quot;apple&quot;,&quot;orange&quot;],[&quot;us&quot;,missing,&quot;us&quot;,&quot;eu&quot;,&quot;us&quot;],[1.1,2.2,3.3,missing,5.5]]
julia&gt; dimNames = [&quot;item&quot;,&quot;region&quot;]
julia&gt; t = NDSparse(content...,names=Symbol.(dimNames))
julia&gt; df = toDataFrame(t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/67b80d04cb0e1a1776bdaefff3a10339668dafe7/src/MultiDimEquations.jl#L372-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MultiDimEquations.@meq-Tuple{Any}" href="#MultiDimEquations.@meq-Tuple{Any}"><code>MultiDimEquations.@meq</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">meq(exp)</code></pre><p>Macro to expand functions like <code>t[d1 in dim1, d2 in dim2, dfix,..] = value</code></p><p>With this macro it is possible to write:</p><pre><code class="language-none">@meq par1[d1 in DIM1, d2 in DIM2, dfix3] =  par2[d1,d2]+par3[d1,d2]</code></pre><p>and obtain</p><pre><code class="language-none">[par1[d1,d2,dfix3] =  par2[d1,d2]+par3[d1,d2] for d1 in DIM1, d2 in DIM2]</code></pre><p>That is, it is possible to write &quot;model equations&quot; in a concise and readable way.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sylvaticus/MultiDimEquations.jl/blob/67b80d04cb0e1a1776bdaefff3a10339668dafe7/src/MultiDimEquations.jl#L284-L302">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 28 April 2021 12:56">Wednesday 28 April 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
